type ('a0, 'a1, 'a2) subTypeParameter =
  { maybeA : ('a0) option
  ; listB : ('a1) list
  ; bAndInt : ('a2 * int)
  }

let encodeSubTypeParameter (type a0) (type a1) (type a2) (encodeA0 : a0 -> Js_json.t) (encodeA1 : a1 -> Js_json.t) (encodeA2 : a1 -> Js_json.t) (x : (a0, a1) subTypeParameter) :Js_json.t =
  Json.Encode.object_
    [ ( "maybeA", (Json.Encode.list encodeA0) x.maybeA )
    ; ( "listB", Json.Encode.int x.listB )
    ; ( "cAndInt", (fun (a,b) -> Json.Encode.array [| encodeA2 a ; Json.Encode.int b  |]) x.cAndInt )
    ]

let decodeSubTypeParameter (type a0) (type a1) (type a2) (decodeA0 : Js_json.t -> (a0, string) Js_result.t) (decodeA1 : Js_json.t -> (a1, string) Js_result.t) (decodeA1 : Js_json.t -> (a2, string) Js_result.t) (json : Js_json.t) :((a0, a1) subTypeParameter, string) Js_result.t =
  match Json.Decode.
    { maybeA = optional (field "maybeA" (fun a -> unwrapResult (decodeA0 a))) json
    ; listB = field "as" (list (fun a -> unwrapResult (decodeA1 a))) json
    ; cAndInt = field "cAndInt" (pair (fun a -> unwrapResult (decodeA2 a)) int) json
    }
  with
  | v -> Js_result.Ok v
  | exception Json.Decode.DecodeError message -> Js_result.Error ("decodeSubTypeParameter: " ^ message)
